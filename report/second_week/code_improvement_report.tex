\documentclass[12pt]{report}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	filecolor=magenta,
	urlcolor=cyan,
	pdftitle={Overleaf Example},
	pdfpagemode=FullScreen,
}
\usepackage{csquotes}
\usepackage{graphicx}

\title{Code improvement report}
\author{Roblox prime numbers:\\\small{Oleh Basystyi}\\\small{Anna Stasyshyn}
	\\\small{Artur Rudish}\\\small{Anton Valihurskyi}\\\small{Maksym Zhuk}}
\date{April 2024}
\begin{document}
	\maketitle
	\renewcommand{\thesection}{\arabic{section}}
	\section{Introduction}
	In this little research, our team researched AI’s capability to optimize Python
	code in different respects: \textit{style}, \textit{memory usage}, \textit{runtime}. In this part, we used
	only \textbf{\textit{ChatGPT-3.5}} and \textbf{\textit{Copilot}}. Here, we will provide only aggregate
	conclusions among different types of optimization techniques. Full list of
	used tasks with some statistical data as \textit{lines of code before and after the
	optimization, runtime}, and a detailed summary of each task can be found in
	\href{https://docs.google.com/spreadsheets/d/1qXPyAJsOOpmtxIoGqObwG5mTaLU3IWO0SQRGbjZPhEc/edit#gid=0}{table on second sheet}. Also, we have the \href{https://github.com/n1n1n1q/Ai-benchmark/tree/main/Ai-tests/Style-and-Code-improvement}{GitHub} with where you can find original and optimized versions of problems.

	\section{ChatGPT-3.5 vs Copilot}

		ChatGPT-3.5 vs Copilot
		At the beginning of this part, our team decided to use these two AIs.
		And, on average, we can see that ChatGPT-3.5 fits better for code optimization
		than Copilot. Especially, you can see that in the first seven rows in the
		 \href{https://docs.google.com/spreadsheets/d/1qXPyAJsOOpmtxIoGqObwG5mTaLU3IWO0SQRGbjZPhEc/edit#gid=0}{table}.
		So it is better to avoid unnecessary struggles and use Copilot only for code generation.



	\section{Style optimization}

		From our observations, we can say that ChatGPT is very good at improving code style and readability.
		It can analyze the codebase, split it into separate
		blocks, write code that will be far more readable than the original one. Additionally, Chat-
		GPT showed a great capability of rewriting code to fit the functional paradigm.
		Moreover, AI is good at following PEP8, with some exceptions, when it becomes
		ignorant of pylint messages.
		However, some issues occurred. When AI rewrites complex or illogically
		written code, it tends to forget some details, such as writing module docstring or
		totally forgets about the existence of a particular function. Moreover, if the precedence
		of operations is crucial in original code; it can rearrange them incorrectly.
		Despite the listed issues, we think that AI’s work with style improvement was good
		enough, so they can be used to optimize the style of great volumes of legacy code,
		if it has enough test coverage to avoid the listed AI lags.

	\section{Runtime \& memory optimization}


		As we have seen in our research, AI struggles with fully independent code optimization. It never gets sent the correct code on the first try. As mentioned many times
		before, AI just forgot about crucial details to make code more readable, and the
		output ends up being just totally not-working code, as in the

		\href{https://docs.google.com/spreadsheets/d/1qXPyAJsOOpmtxIoGqObwG5mTaLU3IWO0SQRGbjZPhEc/edit#gid=0}{table \#2, rows 14, 18}. However, after several manual directions on what was done wrong, we can improve the
		performance, but it only works with problems with an uncomplicated description and
		simple code as in the table \#2, row 18, but struggles to do
		the same thing in the task as shown in row 18.


	\section{Corner cases problem optimization}

		Furthermore, we have tested how AI can work with Pandas in the \href{https://docs.google.com/spreadsheets/d/1qXPyAJsOOpmtxIoGqObwG5mTaLU3IWO0SQRGbjZPhEc/edit#gid=0}{table \#2, rows 8-9} and OOP, row 10. In conclusion, ChatGPT manages to understand the purpose of
		the functions and tries to improve them where possible. In both Pandas problems
		it improved the readability of long filters by dividing them into separate blocks but,
		as was said before, sometimes it changed the order of the operations and, as a result, broke the program. In addition, ChatGPT managed to find unnecessary parts of the code and
		eliminate them correctly, which improved code memory usage and run-
		time.

		In OOP optimization, we noticed the following AI behaviors:

		\begin{itemize}
			\item It tends to select parts of the script (classes) where optimization is mostly
			needed and sends only the changed version of those parts - and this is very
			convenient. On the other hand, when AI does that, it usually forgets about the
			existence of other classes in the script.
			\item It tends to forget to include all methods in the optimized version and
			to inherit all parent classes.
			\item It does not totally understand OOP principles and can move methods
			from base to child classes.
		\end{itemize}

		Therefore, when you try to optimize OOP through AI, these issues should be taken
		into consideration. It’s better to use the following prompts:

		\begin{itemize}
			\item Please optimize this code \textbf{\textit{\{code\}}} this is the problem description
			\textbf{\textit{\{problem\_statement\}}} and the required test cases \textbf{\textit{\{test\_cases\}}}.
			\item Optimize code, do not remove distinct classes.
			\item Do not copy methods from parent classes to child classes.
	\end{itemize}

	\section{Conclusion}
		To summarize, as of today, AI is not capable of optimizing code independently and correctly. It always forgets something important or is unresponsive to
		different prompts and sends the same solution with unchanged bugs. In spite of
		this, AI can make code far more readable, but it is not guaranteed that it
		will 100\% retain its validity. However, generally AI can give the developer relevant and useful hints at what small changes can be made in order to make significant improvements.
		In order to use AI for code optimization, you should follow these
		Recommendations:


		\begin{itemize}
			\item In the beginning you should send all of \textbf{problem description, code, and test cases}.
			\item Try not to give general promts like \textit{"Optimize this code"}, but specify what part of program
			must be optimized.
			\item If AI struggles to solve the bug after several prompts (sends the same code) you should provide \textbf{function name} or \textbf{class name} where the error occurred.
			\item Sometimes AI struggle to solve even the PEP8 errors from error signatures, so you should send prompt like \textit{"Split the documentation into two lines"}, because AI can be irresponsible to prompt like \textit{"10th line is to long, make it shoter"}.
			\item Do not rely on AI completely: you should only use it to search for optimization hints but not as complete tool for code improvement.
		\end{itemize}


\end{document}
